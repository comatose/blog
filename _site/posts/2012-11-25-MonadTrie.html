<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
    <title>Lambda Play - MonadTrie</title>
    <link rel="stylesheet" type="text/css" href="../css/default.css"></link>
    <link rel="stylesheet" type="text/css" href="../css/syntax.css"></link>
    <link rel="stylesheet" type="text/css" href="../css/style.css"></link>

    <link rel="alternate" type="application/rss+xml" title="Lambda Play" href="../rss.xml"></link>
  </head>
  <body>
    <center>
    <table cellpadding="0,0,0,0" cellspacing="0,0,0,0" border="0" bgcolor="white">
      <tr>
	<td rowspan="2" height="190" width="88" style="background-image:url(../images/tw_left.png); background-repeat:no-repeat;"></td>
	<td height="109" width="400" style="background-image:url(../images/tw_middle_m.png); background-repeat:repeat-x;"><img src="../images/tw_middle_l.png" height="109" border="0"></img></td>
	<td height="109" width="200" align="right" style="background-image:url(../images/tw_middle_m.png); background-repeat:repeat-x;"><img src="../images/tw_middle_r.png" height="109" border="0"></img></td>
	<td rowspan="2" height="190" width="93" style="background-image:url(../images/tw_right.png); background-repeat:no-repeat;"></td>
      </tr>
      <tr>
	<td colspan="2" valign="top" height="81" bgcolor="white">
	  <h1><a href="../">Lambda Play</a> - MonadTrie</h1>
	  <div id="navigation">
            <a href="../">Home</a>
            <a href="../posts.html">All posts</a>
          </div>	  
	</td>
      </tr>
      <tr>
	<td width="88" background="../images/tw_left_bg.png"></td>
	<td colspan="2" valign="top">
	  <script type="text/javascript">
    var disqus_developer = 1;
</script>

<h1>MonadTrie</h1>

<p>by <em>comatose</em> on <strong>November 25, 2012</strong></p>

<p>Tagged as: <a href="../tags/haskell.html">haskell</a>, <a href="../tags/memoization.html">memoization</a>.</p>

<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Array</span>
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Function</span>
<span class="fu">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.MemoTrie</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="fu">&gt;</span> <span class="kw">import</span>           <span class="dt">System.Environment</span></code></pre>
<p><a href="http://localhost:5907/posts/2011-10-09-Y-Combinator3.html">여기</a>에서 소개한 <a href="http://www.haskell.org/haskellwiki/MemoTrie">MemoTrie</a>는 처음 접했을 때는 그냥 magic이었다.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> fibG ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="fu">&gt;</span> fibG _ <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
<span class="fu">&gt;</span> fibG _ <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
<span class="fu">&gt;</span> fibG f n <span class="fu">=</span> f (n <span class="fu">-</span> <span class="dv">1</span>) <span class="fu">+</span> f (n <span class="fu">-</span> <span class="dv">2</span>)</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> fibMagic <span class="fu">=</span> fix (M.memo <span class="fu">.</span> fibG)</code></pre>
<p>IO를 쓰지 않고 라이브러리 수준에서 이렇게 간결한 memoization을 제공하는 게 가능한지 의심될 정도였는데, 최근에 <a href="http://hackage.haskell.org/packages/archive/MemoTrie/0.5/doc/html/src/Data-MemoTrie.html#HasTrie">source</a>를 보고서 수수께끼를 풀었다.</p>
<p>결국, MemoTrie도 lazy evaluation을 이용한 memoization 인데, 예를 들면</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> fibLazy ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="fu">&gt;</span> fibLazy <span class="fu">=</span> (tab <span class="fu">!!</span>)
<span class="fu">&gt;</span>   <span class="kw">where</span> tab <span class="fu">=</span> <span class="fu">map</span> f [<span class="dv">0</span><span class="fu">..</span>]
<span class="fu">&gt;</span>         f <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
<span class="fu">&gt;</span>         f <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
<span class="fu">&gt;</span>         f n <span class="fu">=</span> fibLazy (n <span class="fu">-</span> <span class="dv">1</span>) <span class="fu">+</span> fibLazy (n <span class="fu">-</span> <span class="dv">2</span>)</code></pre>
<p>일반적인 List를 이용한 memoization의 구현인 <code>fibLazy</code>에서 <code>f</code>를 open recursion으로 변형하고</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> fibLazy' <span class="fu">=</span> (tab <span class="fu">!!</span>)
<span class="fu">&gt;</span>   <span class="kw">where</span> tab <span class="fu">=</span> <span class="fu">map</span> (fibG (tab <span class="fu">!!</span>)) [<span class="dv">0</span><span class="fu">..</span>]
<span class="fu">&gt;</span> 
<span class="fu">&gt;</span> fibLazy'' <span class="fu">=</span> at
<span class="fu">&gt;</span>   <span class="kw">where</span> at <span class="fu">=</span> (<span class="fu">map</span> (fibG at) [<span class="dv">0</span><span class="fu">..</span>] <span class="fu">!!</span>)
<span class="fu">&gt;</span> 
<span class="fu">&gt;</span> fibLazy''' <span class="fu">=</span> at
<span class="fu">&gt;</span>   <span class="kw">where</span> at <span class="fu">=</span> (\f <span class="ot">-&gt;</span> (<span class="fu">map</span> f [<span class="dv">0</span><span class="fu">..</span>] <span class="fu">!!</span>)) (fibG at)
<span class="fu">&gt;</span> 
<span class="fu">&gt;</span> fibLazy'''' <span class="fu">=</span> fix atG
<span class="fu">&gt;</span>   <span class="kw">where</span> atG at <span class="fu">=</span> (\f <span class="ot">-&gt;</span> (<span class="fu">map</span> f [<span class="dv">0</span><span class="fu">..</span>] <span class="fu">!!</span>)) (fibG (at))
<span class="fu">&gt;</span> 
<span class="fu">&gt;</span> fibLazy''''' <span class="fu">=</span> fix atG
<span class="fu">&gt;</span>   <span class="kw">where</span> atG <span class="fu">=</span> (\f <span class="ot">-&gt;</span> (<span class="fu">map</span> f [<span class="dv">0</span><span class="fu">..</span>] <span class="fu">!!</span>)) <span class="fu">.</span> fibG</code></pre>
<p>이제, <code>memo</code>를 추출할 수 있다.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> fibLz ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)
<span class="fu">&gt;</span> fibLz <span class="fu">=</span> fix (memo <span class="fu">.</span> fibG)
<span class="fu">&gt;</span>   <span class="kw">where</span><span class="ot"> memo ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)
<span class="fu">&gt;</span>         memo <span class="fu">=</span> \f <span class="ot">-&gt;</span> (<span class="fu">map</span> f [<span class="dv">0</span><span class="fu">..</span>] <span class="fu">!!</span>)</code></pre>
<p>다시, <code>memo</code>를 좀 더 분리해보면,</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> memo ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)
<span class="fu">&gt;</span> memo <span class="fu">=</span> untabify <span class="fu">.</span> tabify
<span class="fu">&gt;</span>   <span class="kw">where</span>
<span class="fu">&gt;</span><span class="ot">     tabify ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
<span class="fu">&gt;</span>     tabify f <span class="fu">=</span> (<span class="fu">map</span> f [<span class="dv">0</span><span class="fu">..</span>])
<span class="fu">&gt;</span><span class="ot">     untabify ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)
<span class="fu">&gt;</span>     untabify <span class="fu">=</span> (<span class="fu">!!</span>)</code></pre>
<p>결국 <code>memo</code>가 하는 일은 함수를 자료구조로 만들고(<code>tabify</code>) 다시 함수로 만들어주는(<code>untabify</code>) 것이다.</p>
<p>List가 비효율적이면 <code>memo'</code>처럼 Array를 사용할 수 있다.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> memo' ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)
<span class="fu">&gt;</span> memo' sz <span class="fu">=</span> untabify <span class="fu">.</span> tabify
<span class="fu">&gt;</span>   <span class="kw">where</span> 
<span class="fu">&gt;</span><span class="ot">     tabify ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Array</span> <span class="dt">Int</span> <span class="dt">Integer</span>
<span class="fu">&gt;</span>     tabify f <span class="fu">=</span> listArray (<span class="dv">0</span>, sz) (<span class="fu">map</span> f [<span class="dv">0</span><span class="fu">..</span>])
<span class="fu">&gt;</span><span class="ot">     untabify ::</span> <span class="dt">Array</span> <span class="dt">Int</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)
<span class="fu">&gt;</span>     untabify <span class="fu">=</span> (<span class="fu">!</span>)</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> fibLz' ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)
<span class="fu">&gt;</span> fibLz' n <span class="fu">=</span> fix (memo' n <span class="fu">.</span> fibG) n</code></pre>
<p>하지만, List나 Array는 양의 정수만 인자로 받기 때문에 좀 더 일반적인 container가 필요한데 <a href="http://www.haskell.org/haskellwiki/MemoTrie">MemoTrie</a>는 이런 목적으로 trie를 사용한 것이다. 고로, <code>tabify</code> 는 <code>trie</code>로 <code>untabify</code>는 <code>untrie</code>가 된다.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span><span class="ot"> main ::</span> <span class="dt">IO</span> ()
<span class="fu">&gt;</span> main <span class="fu">=</span> getArgs <span class="fu">&gt;&gt;=</span> <span class="fu">print</span> <span class="fu">.</span> fibLz' <span class="fu">.</span> <span class="fu">read</span> <span class="fu">.</span> <span class="fu">head</span></code></pre>
<p>근데, <a href="2012-11-25-MonadMemo.html">MonadMemo</a>가 더 빠르다.</p>

<div id="disqus_thread"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'lambdaplay'; // required: replace example with your forum shortname
  var disqus_identifier = '/posts/2012-11-25-MonadTrie.html';
  var disqus_title = 'MonadTrie';
  
  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

	</td>
	<td width="93" align="right" background="../images/tw_right_bg.png"></td>
      </tr>
    </table>
  </body>
</html>
